import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;

void main() => runApp(const DigimonApp());

class DigimonApp extends StatelessWidget {
  const DigimonApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Digimon API Demo',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(colorSchemeSeed: Colors.deepPurple, useMaterial3: true),
      home: const DigimonHomePage(),
    );
  }
}

/// MODELO
class Digimon {
  final int id;
  final String name;
  final String image;
  final String level;
  final String types;
  final List<String> attrib;
  final List<String> descrip;
  final String? descriptionEn; // <- ahora nullable

  Digimon({
    required this.id,
    required this.name,
    required this.image,
    required this.level,
    required this.types,
    required this.attrib,
    required this.descrip,
    this.descriptionEn, // <- puede ser null
  });

  factory Digimon.fromJson(Map<String, dynamic> json) {
    // Listas defensivas
    final descListDynamic = (json['descriptions'] as List?) ?? const [];
    final images = (json['images'] as List?) ?? const [];
    final levels = (json['levels'] as List?) ?? const [];
    final typesL = (json['types'] as List?) ?? const [];
    final attribs = (json['attributes'] as List?) ?? const [];

    // Buscar descripción EN
    String? english;
    for (final item in descListDynamic) {
      final m = (item is Map) ? item : null;
      final lang = (m?['language'] ?? '').toString().toLowerCase();
      if (lang.startsWith('en')) {
        final candidate = (m?['description'] ?? '').toString();
        if (candidate.isNotEmpty) {
          english = candidate;
          break;
        }
      }
    }
    // Fallback a la primera (si no hubo EN y existe alguna)
    if ((english == null || english.isEmpty) && descListDynamic.isNotEmpty) {
      final first = descListDynamic.first;
      final candidate =
          (first is Map ? (first['description'] ?? '') : '').toString();
      english = candidate.isNotEmpty ? candidate : null;
    }

    return Digimon(
      id: (json['id'] is int)
          ? json['id'] as int
          : int.tryParse('${json['id'] ?? 0}') ?? 0,
      name: (json['name'] ?? 'Desconocido').toString(),
      image: images.isNotEmpty
          ? ((images.first is Map)
                  ? ((images.first as Map)['href'] ?? '')
                  : '')
              .toString()
          : '',
      level: levels.isNotEmpty
          ? ((levels.first is Map)
                  ? ((levels.first as Map)['level'] ?? '')
                  : '')
              .toString()
          : '',
      types: typesL.isNotEmpty
          ? ((typesL.first is Map)
                  ? ((typesL.first as Map)['type'] ?? '')
                  : '')
              .toString()
          : '',
      attrib: attribs
          .whereType<Map>()
          .map((a) => (a['attribute'] ?? '').toString())
          .toList(),
      descrip: descListDynamic
          .whereType<Map>()
          .map((d) => (d['description'] ?? '').toString())
          .toList(),
      descriptionEn: english, // <- puede quedar null
    );
  }
}

/// WIDGET PRINCIPAL
class DigimonHomePage extends StatefulWidget {
  const DigimonHomePage({super.key});

  @override
  State<DigimonHomePage> createState() => _DigimonHomePageState();
}

class _DigimonHomePageState extends State<DigimonHomePage> {
  List<Digimon> _digimons = [];
  List<Digimon> _filtered = [];
  bool _loading = false;
  bool _loadingMore = false;
  int _currentPage = 0;
  final int _pageSize = 20;

  final ScrollController _scrollController = ScrollController();
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    fetchDigimons();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  /// FETCH con detalles + paginación
  Future<void> fetchDigimons() async {
    if (_loadingMore) return;

    setState(() {
      _loading = _digimons.isEmpty;
      _loadingMore = true;
    });

    try {
      final response = await http.get(
        Uri.parse(
          'https://digi-api.com/api/v1/digimon?page=$_currentPage&pageSize=$_pageSize',
        ),
      );

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final List<dynamic> digimonList = data['content'] ?? [];

        List<Digimon> fetched = [];

        for (var digimonData in digimonList) {
          try {
            final id = (digimonData is Map) ? digimonData['id'] : null;
            if (id == null) continue;

            final detailResponse =
                await http.get(Uri.parse('https://digi-api.com/api/v1/digimon/$id'));

            if (detailResponse.statusCode == 200) {
              final detailData = json.decode(detailResponse.body);
              if (detailData is Map<String, dynamic>) {
                fetched.add(Digimon.fromJson(detailData));
              }
            }
          } catch (e) {
            debugPrint(
                'Error al cargar digimon ${digimonData is Map ? digimonData['id'] : 'desconocido'}: $e');
          }
        }

        setState(() {
          _digimons.addAll(fetched);
          _filtered = _digimons;
          _currentPage++;
          _loading = false;
          _loadingMore = false;
        });
      } else {
        throw Exception('Error al cargar lista');
      }
    } catch (e) {
      setState(() {
        _loading = false;
        _loadingMore = false;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error al cargar Digimons: $e')),
      );
    }
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
            _scrollController.position.maxScrollExtent - 200 &&
        !_loadingMore) {
      fetchDigimons();
    }
  }

  void _filterDigimons(String query) {
    setState(() {
      if (query.isEmpty) {
        _filtered = _digimons;
      } else {
        _filtered = _digimons
            .where(
              (d) =>
                  d.name.toLowerCase().contains(query.toLowerCase()) ||
                  d.level.toLowerCase().contains(query.toLowerCase()) ||
                  d.types.toLowerCase().contains(query.toLowerCase()),
            )
            .toList();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Digimon Explorer")),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: "Buscar Digimon...",
                prefixIcon: const Icon(Icons.search),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(20),
                ),
              ),
              onChanged: _filterDigimons,
            ),
          ),
          Expanded(
            child: _loading
                ? const Center(child: CircularProgressIndicator())
                : GridView.builder(
                    controller: _scrollController,
                    padding: const EdgeInsets.all(8),
                    gridDelegate:
                        const SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: 2,
                      childAspectRatio: 0.75,
                    ),
                    itemCount: _filtered.length + (_loadingMore ? 1 : 0),
                    itemBuilder: (context, index) {
                      if (index == _filtered.length && _loadingMore) {
                        return const Center(
                          child: Padding(
                            padding: EdgeInsets.all(12),
                            child: CircularProgressIndicator(),
                          ),
                        );
                      }
                      return DigimonCard(digimon: _filtered[index]);
                    },
                  ),
          ),
        ],
      ),
    );
  }
}

/// TARJETA con animación
class DigimonCard extends StatefulWidget {
  final Digimon digimon;

  const DigimonCard({super.key, required this.digimon});

  @override
  State<DigimonCard> createState() => _DigimonCardState();
}

class _DigimonCardState extends State<DigimonCard>
    with SingleTickerProviderStateMixin {
  late AnimationController controller;
  late Animation<double> scaleAnimation;
  late Animation<Offset> slideAnimation;

  @override
  void initState() {
    super.initState();
    controller = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );

    scaleAnimation = Tween<double>(begin: 0.8, end: 1.0).animate(
      CurvedAnimation(parent: controller, curve: Curves.easeInOut),
    );

    slideAnimation = Tween<Offset>(
      begin: const Offset(1.0, 0.0),
      end: Offset.zero,
    ).animate(CurvedAnimation(parent: controller, curve: Curves.easeOutCubic));

    controller.forward();
  }

  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final d = widget.digimon;
    return SlideTransition(
      position: slideAnimation,
      child: ScaleTransition(
        scale: scaleAnimation,
        child: Card(
          elevation: 8,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(20),
          ),
          margin: const EdgeInsets.all(10),
          child: Padding(
            padding: const EdgeInsets.all(10),
            child: Column(
              children: [
                Expanded(
                  child: (d.image.isNotEmpty)
                      ? Image.network(
                          d.image,
                          fit: BoxFit.contain,
                          errorBuilder: (_, __, ___) => const Icon(
                            Icons.broken_image,
                            size: 60,
                            color: Colors.grey,
                          ),
                        )
                      : const Icon(
                          Icons.image_not_supported,
                          size: 60,
                          color: Colors.grey,
                        ),
                ),
                const SizedBox(height: 8),
                Text(
                  d.name,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.deepPurple,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 4),
                if (d.level.isNotEmpty) Text("Nivel: ${d.level}"),
                if (d.types.isNotEmpty) Text("Tipo: ${d.types}"),
                if (d.attrib.isNotEmpty)
                  Text("Atributos: ${d.attrib.join(", ")}"),
                const SizedBox(height: 8),

                // ===== Botón con AlertDialog usando descriptionEn nullable =====
                OutlinedButton.icon(
                  icon: const Icon(Icons.info_outline),
                  label: const Text('Descripción'),
                  onPressed: () {
                    try {
                      final String text = (() {
                        final en = d.descriptionEn;
                        if (en != null && en.trim().isNotEmpty) {
                          return en.trim();
                        }
                        if (d.descrip.isNotEmpty) {
                          final first = d.descrip.first;
                          if (first.trim().isNotEmpty) return first.trim();
                        }
                        return 'Sin descripción disponible.';
                      })();

                      final String title =
                          d.name.trim().isNotEmpty ? d.name.trim() : 'Sin nombre';

                      showDialog(
                        context: context,
                        builder: (ctx) => AlertDialog(
                          title: Text(title),
                          content: SingleChildScrollView(child: Text(text)),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.of(ctx).pop(),
                              child: const Text('Cerrar'),
                            ),
                          ],
                        ),
                      );
                    } catch (e, st) {
                      debugPrint('Error mostrando descripción: $e\n$st');
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('No se pudo mostrar la descripción.'),
                        ),
                      );
                    }
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
